## 6.9 Promise 프로미스

### 1. 자바스크립트에서의 콜백 패턴의 단점

1. 가독성이 나쁨
2. 비동기 처리 중 발생한 에러의 예외 처리가 곤란함
3. 여러 개의 비동기 처리 로직을 한꺼번에 처리 하는것도 한계가 있다.



### 2. 프로미스의 특징

전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현함.



### 3. 콜백 패턴의 단점



1. 콜백 헬

   여러개의 콜백 함수가 네스팅되어 복잡도가 높아지는것

   콜백 헬은 가독성을 나쁘게 하며 실수를 유발하는 원인이 된다.



2. 에러 처리의 한계



### 4. 프로미스의 생성

프로미스는 Promise 생성자 함수를 통해 인스턴스화 한다.

Promise 생성자 함수는 비동기 작업을 수행할 콜백 함수를 인자로 전달받는데 이 콜백 함수는 resolve와 reject 함수를 인자로 전달받는다.



```javascript
const promise = new Promise((resolve, reject) => {
	if(){
		resolve('result');
	}
	else{
		reject('failure reason');
	}
});
```



Promise는 비동기 처리가 성공하였는지 또는 실패하였는지 등의 상태정보를 갖는다.

|   상태    |                    의미                    |                        구현                        |
| :-------: | :----------------------------------------: | :------------------------------------------------: |
|  pending  |   비동기 처리가 아직 수행되지 않은 상태    | resolve 또는 reject 함수가 아직 호출되지 않은 상태 |
| fulfilled |      비동기 처리가 수행된 상태 (성공)      |            resolove 함수가 호출된 상태             |
| rejected  |      비동기 처리가 수행된 상태 (실패)      |             reject 함수가 호출된 상태              |
|  settled  | 비동기 처리가 수행된 상태 (성공 또는 실패) |       resolve 또는 reject 함수가 호출된 상태       |



Promise 생성자 함수가 인자로 전달받은 콜백 함수는 내부에서 비동기 처리 작업을 수행한다. 이때 비동기 처리가 성공하면 콜백 함수의 안자로 전달받은 resolve 함수를 호출한다. 이때 프로미스는 fullfilled 상태가 된다.

비동기 처리가 실패하면 reject 함수를 호출한다. 이때 프로미스는 rejected 상태가 된다. 



### 5. 프로미스의 후속 처리 메소드



1. 종류 : 

   1. then : 두개의 콜백 함수를 인자로 전달 받는다. 첫 번째 콜백 함수는 성공시 호출되고 두 번째 함수는 실패시 호출된다. then 메소드는 Promise를 반환한다.

   

   2. catch : 예외가 발생하면 호출된다. catch 메소드는 Promise를 반환한다.



### 6. 프로미스의 에러 처리

비동기 처리 시 발생한 에러 메세지는 then 메소드의 두 번째 콜백 함수로 전달된다. Promise 객체의 후속 처리 메소드 catch을 사용하여도 에러를 처리할 수 있다.



catch 메소드는 에러를 처리한다는 점에서 then 메소드의 두 번째 콜백 함수와 유사하지만 미묘한 차이가 있다. then 메소드의 두 번째 콜백 함수는 비동기 처리에서 발생한 에러만을 캐치한다. 하지만 catch 메소드는 비동기 처리에서 발생한 에러 뿐만 아니라 then 메소드 내부에서 발생한 에러도 캐치한다. 따라서 에러처리는 catch 메소드를 사용하는 편이 보다 효율적이다.



### 7. 프로미스 체이닝

프로미스는 후속 처리 메소드를 체이닝하여 여러 개의 프로미스를 연결하여 사용할 수 있다.

then 메소드가 Promise 객체를 반환하도록 하면 여러 개의 프로미스를 연결하여 사용할 수 있다.



### 8. 프로미스의 정적 메소드

1. Promise.resolve/Promise.reject

   존재하는 값을 Promise로 래핑하기 위해 사용한다.

   정적 메소드 Promise.resolve 메소드는 인자로 전달된 값을 resolve 하는 Promise를 생성한다.

2. Promise.all

   프로미스가 담겨 있는 배열 등의 이터러블을 인자로 전달 받는다. 그리고 전달받은 모든 프로미스를 병렬로 처리하고 그 처리 결과를 resolve하는 새로운 프로미스를 반환한다.

3. Promise.race

   promise.all 메소드와 동일하게 프로미스가 담겨 있는 배열 등의 이터러블을 인자로 전달 받는다. 그리고 Promise.race 메소드는 Promise.all 메소드처럼 모든 프로미스를 병렬 처리 하는것이 아니라 가장 먼저 처리된 프로미스가 resolve한 처리 결과를 resolve하는 새로운 프로미스를 반환한다.

   에러가 발생한 경우는 Promise.all 메소드와 동일하게 처리된다. 즉, Promise.race 메소드에 전달된 프로미스 처리가 하나라도 실패하면 가장 먼저 실패한 프로미스가 reject한 에러를 reject하는 새로운 프로미스를 즉시 반환한다.

   

   