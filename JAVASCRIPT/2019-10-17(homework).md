## 18. 프로토타입

### 1. 시작전 알아두기

- 자바스크립트 : 프로토타입 기반의 객체지향 프로그래밍 언어
- 클래스 특징 : 
  1. 인스턴스를 생성하지만 프로토타입과 동일하게 동작하지 않음
- 모든 객체는 하나의 프로토타입을 갖으며 프로토타입은 객체의 생성 방식에 의해 결정됨
  - 객체 리터럴에 의해 생성된 객체의 프로토타입 : Object.prototype
  - 생성자 함수에 의해 생성된 객체의 프로토타입 : 생성자 함수의 prototype 프로퍼티



### 2. 객체지향 프로그래밍

- 의미 : 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 프로그램을 여러 개의 독립적 단위, 즉 객체들의 집합으로 표현하려는 프로그래밍 패러다임을 말함.
- Tip : 
  1. 추상화 : 다양한 속성중에서 프로그램에 필요한 속성만을 간추려 내어 표현하는것
  2. 객체 : 
     1. 의미 : 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료 구조
     2. 특징 : 자신의 고유한 기능을 수행하면서 다른 객체와 관계성을 갖을 수 있다.



### 3. 상속과 프로토타입

- 상속의 의미 : 

  어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할수 있는것

- 프로토타입의 특징 : 

  어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메소드 포함)를 제공함.

  

- 프로토타입을 기반이면 좋은점:

  1. 상속을 구현하여 불필요한 중복을 제거할수 있음
  2. 기존 코드의 재사용성을 높일수 있음
  3. 개발 비용 줄일수 있음

  ex) 기존 생성자 함수(메소드가 같은)를 쓰게되면 똑같은 메서드 객체들이 메모리에 잔뜩 생겨서 메모리의 효율을 낮춤. 이때 메소드를 프로퍼티로 설정함으로써 모든 인스턴스가 공유할수 있도록 함





### 4. 프로토타입 객체

- 특징 : 
  1. 객체 지향 프로그래밍의 근간을 이루는 객체간 상속을 구현하기 위해 사용됨

- Tip : 프ㅗ토타입은 객체의 생성방식에 의해 달라짐



#### 4.1 __ proto __ 접근자 프로퍼티

- 접근자 프로퍼티의 특징

  1. 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티
  2. 상속을 통해 사용됨.
  3. 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티임 따라서 Object.prototype의 접근자 프로퍼티 __ proto __를 상속받아 사용할 수 있음.

- 특징 : 모든 객체는 __ proto __ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있음.

- __ proto __ 접근자 프로퍼티가 하는일

  1. getter / setter 함수라고 부르는 접근자 함수를 통해 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입을 취득하거나 할당함.
  2. __ proto __ 접근자 프로퍼티를 통해 프로토타입에 접근하면 내부적으로 __ proto __ 접근자 프로퍼티의 getter 함수인 get __ proto __ 가 호출됨
  3. __ proto __ 접근자 프로퍼티를 통해 새로운 프로토타입을 할당하면  __ proto __ 접근자 프로퍼티의 setter 함수인 set __ proto __ 가 호출됨

- 내부 메소드 [GetPrototypeOf]] 와 [[SetPrototypeOf]] 

  get __ proto __ 은 [[GetPrototypeOf]] 내부 메소드를 호출하여 자신의 프로토타입을 취득하고, set __ proto __ 은 [[SetPrototypeOf]] 내부 메소드를 호출하여 새로운 프로토타입을 할당함.

- 프로토타입 체인 

  설명 : 

  1. 모든 객체는 프로토타입의 계층 구조인 프로토타입 체인에 묶여있음.

  2. 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 __ proto __ 접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색함.

- 왜 쓸까? : 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함.

  1. 왜? : 프로토타입 체인은 단방향 링크드 리스트로 구현되야됨.



- 코드내에서는 왜 사용을 비추천할까? : 모든 객체가 __ proto __를 접근자 프로퍼티를 사용할수 있는건 아니기 때문
  - 그래서 ? : 
    1. 프로토타입의 참조를 취득할 경우 : Object.getPrototypeOf 메소드 사용
    2. 프로토타입을 교체하는 경우 : Object.setPrototypeOf 메소드 사용



#### 4.2 함수 객체의 prototype 프로퍼티

- 특징 : 

  1. prototype 프로퍼티는 함수 객체(constructor)만 소유하고 있는 프로퍼티
  2. 함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입 가리킴

- __ proto __ 접근자 프로퍼티와 함수객체가 가지고 있는 prototype 프로퍼티 비교

  | 구분                        | 소유      | 값                | 사용주체    | 사용목적                                                     |
  | --------------------------- | --------- | ----------------- | ----------- | ------------------------------------------------------------ |
  | __ proto __ 접근자 프로퍼티 | 모든 객체 | 프로토타입의 참조 | 모든 객체   | 모든 객체가 상속을 위해 자신의 프로토타입에 접근하기 위해 사용 |
  | prototype 프로퍼티          | 함수객체  | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 객체(인스턴스)의 프로토타입을 할당하기 위해 사용 |



#### 4.3 프로토타입의 constructor 프로퍼티와 생성자 함수

- constructor 프로퍼티의 의미 : 
  1. prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킴





### 5. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

- 리터럴 표기법에 의해 생성된 객체의 예

  1. 객체 리터럴
  2. 함수 리터럴
  3. 배열 리터럴
  4. 정규표현식 리터럴

- 리터럴 표기법에 의해 생성된 객체의 특징

  프로토타입을 가지고 있긴 하지만 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정하지 못함

- Object 생성자 함수와 객체 리터럴의 평가의 공통점과 차이점

  1. 공통점 : 추정 연산 ObjectCreate을 호출하여 빈 객체를 생성한다.
  2. 차이점 : new.target 확인이나 프로퍼티를 추가하는 처리등 세부 내용이 다름



- 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

| 리터럴 표기법      | 생성자 함수 | 프로토타입         |
| ------------------ | ----------- | ------------------ |
| 객체 리터럴        | Object      | Object.protptype   |
| 함수 리터럴        | Function    | Function.prototype |
| 배열 리터럴        | Array       | Array.prototype    |
| 정규 표현식 리터럴 | RegExp      | RegExp.protptype   |



### 6. 프로토타입의 생성시점

#### 6.1 사용자 정의 생성자 함수와 프로토타입 생성 시점

함수 정의가 평가되어 함수 객체를 생성하는 시점에 생성됨.

ex) 함수 선언문으로 생성된 생성자 함수는 함수 호이스팅으로 인해 먼저 평가되어 함수 객체가 되고 	  프로토타입 또한 생성됨.



#### 6.2 빌트인 생성자 함수와 프로토타입 생성 시점

일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성됨

즉 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성

- 용어 정리 : 
  1. 전역 객체 : 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 클라이언트 사이드 환경에서는 window, 서버사이드 환경에서는 global 객체를 의미



### 7. 객체 생성 방식과 프로토타입의 결정



- 객체를 만드는 다양한 방법
  1. 객체 리터럴
  2. Object 생성자 함수
  3. 생성자 함수
  4. Object.create 메소드
  5. 클래스 



- 객체를 만드는 다양한 방법의 공통점 : 

  추상 연산 ObjectCreate에 의해 생성됨 



- 1. 객체 리터럴과 / 2. Object 생성자 함수의 생성 방식 차이

     프로퍼티를 추가하는 방식이 다름

     1. 객체 리터럴 방식 : 객체 리터럴 내부에 프로퍼티를 추가함
     2. Object 생성자 함수 방식 : 일단 빈객체 생성한후 프로퍼티 추가



- Object 생성자 함수와 사용자 정의 생성자 함수 프로토타입의 차이점
  1. Object 생성자 함수 : 다양한 빌트인 메소드를 가지고 잇음
  2. 사용자 정의 생성자 함수 : constructor 프로퍼티만 가지고 있음.



### 8. 프로토타입 체인

- 의미 : 자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 __ proto __ 접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색함 이것을 프로토타입이라함.
- 특징 : 
  1. 최상위에 위치하는 객체는 Object.prototype임
  2. Object.prototype, 즉 [[prototype]] 내부 슬롯의 값은 null임





### 9. 캡슐화

- 의미 : 정보의 일부를 외부에 감추어 은닉하는것을 말함
- 효과 : 
  1. 적절치 못한 접근으로부터 정보를 보호함
  2. 객체간의 상호 의존성, 결합도를 낮춤



### 10. 오버라이딩과 프로퍼티 쉐도잉

- 오버라이딩 

  상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의 하여 사용하는 방식

- 오버로딩

  함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메소드를 구현하고 매개변수에 의해 메소드를 구별하여 호출하는 방식



### 11. 프로토타입의 교체

- 특징 : 
  1. 프로토타입은 임의의 객체로 변경할수 있음
- 어떻게 교체할까?
  1. 생성자 함수에 의해
  2. 인스턴스에 의해 



#### 11.1 생성자 함수에 의한 프로토타입의 교체

- 특징 :
  1. 프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티가 없음
  2. 생성자 함수 간의 링크가 파괴됨
  3. 프로퍼티 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색됨.



#### 11.2 인스턴스에 의한 프로토타입의 교체

- 특징 : 
  1. constructor 프로퍼티와 생성자 함수간의 연결 파괴됨.



#### 11.3 생성된 함수에 의한, 인스턴스에 의한 프로토타입의 교체의 차이점

- 생성된 함수에 의한 : 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입으 가리킴

- 인스턴스에 의한 : 생성자 함수의 prototype 프로퍼티가 교체된 프로퍼티 타입을 가리키지 않음



### 12. instanceof 연산자

- 작동원리 : 
  1. 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스 : true로 평가
  2. 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스가 아님 : false로 평가



- 특징 : 

  프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수를 찾는 것은 생성자 함수가 아니라 프로토타입 체인 상에 존재하는 프로토타입에 영향을 받음



### 13. 직접 상속

#### 13-1. Object.create에 의한 직접 상속

- Object.create 메소드 작동방식 : 

  첫번째 매개변수: 생성할 객체의 프로토타입 객체

  두번째 매개변수: 생성할 객체의 프로퍼티를 갖는 객체

  를 전달하면 지정된 프로퍼티 및 프로퍼티를 갖는 새로운 객체를 반환함

- 장점 : 

  1. new 연산자가 없이도 객체를 생성할 수 있음.
  2. 프로토타입을 지정하면서 객체를 생성할 수 있다. 이때 생서아 함수와 프로토타입 간의 링크가 파괴되지 않음
  3. 객체 리터럴에 의해 생성된 객체도 특정 객체를 상속받을 수 있음.



#### 13-2. 객체 리터럴 내부에서 __ proto __ 에 의한 직접 상속

- 특징 : 객체 리터럴 내부에서 __ proto __ 접근자 프로퍼티를 사용하여 직접 상속을 구현할수 있음.





### 14. 정적 프로퍼티/ 메소드

- 정의 :
  1. 정적 프로퍼티 : 생성자 함수의 프로퍼티
  2. 정적 메소드  : 생성자 함수의 메소드



- 특징 : 

  정적 프로퍼티/ 메소드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없음.



### 15. 프로퍼티 존재 확인

- in 연산자 

  - 동작 방법 : 

    prop : 프로퍼티 키를 나타내는 문자열

    object : 객체로 평가되는 표현식

    prop in object

- 주의점 : in 연산자는 확인 대상 객체의 프로퍼티 뿐만 아니라 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인함.



### 16. 프로퍼티 열거

- for..in 문

  - 특징 : 

    1. 열거할때 순서를 보장하지 않음
    2. 객체의 프로퍼티뿐만 아니라 객체가 상속받은 모든 프로토타입의 프로퍼티를 열거함.
    3. object.prototype의 프로퍼티는 열거되지 않음.

  - 사용시 tip : 

    1. 상속 받은 프로퍼티는 제외하고 객체 자신의 프로퍼티만을 열거하려면?

       Object.prototype.hasOwnProperty 메소드 사용.



## 19. 엄격 모드

### 1. strict mode

- 효과 : 자바스크립트 언어의 문법을 보다 엄격히 적용함/  자바스크립트 엔진의 최적화 작업에 문제를 일으킬수 잇는 코드에 대해 명시적인 에러를 발생시킴



### 2. strict mode 어디에 적용해야할까?

즉시 실행 함수로 감싼 스크립트 단위로 적용하는것이 바람직함.



### 3. strict mode가 발생시키는에러

1. 암묵적 전역변수
2. 변수, 함수, 매개변수의 삭제
3. 매개변수 이름의 중복
4. with 문의 사용

### 4. strict mode 적용에 의한 변화

1. 일반 함수의 this
   - 설명 : 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩됨.
2. arguments 객체 
   - 설명 : 매개변수에 전달된 인수를 재할당하여 변경하여도 arguments객체에 반영되지 않음.



## 20. 전역객체 

### 1. 전역객체 

- 의미 : 클라이언트 사이드 환경에서는 window, 서버사이드 환경에서는 global 객체를 의마함

- 구성 : 표준 빌트인 객체, 환경에 따른 호스트 API, var 키워드로 선언한 전역 변수와 전역 함수

- 특징 :
  1. 전역 객체는 개발자가 의도적으로 생성할 수 없다.
  2. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.
  3. 전역 객체는 Object, String, Number, Boolean, Function, Array, RegExp, Date, Math, Promise와 가튼 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.
  4. 자바스크립트 실행 환경에 따라 추가적으로 프로퍼티와 메소드를 갖는다.
  5. var 키워드로 선언한 전역 변수와 선언하지 않는 변수에 값을 할당한 암묵적 전역 변수, 전역 함수는 전역 객체의 프로퍼티가 된다.



### 2. 전역 프로퍼티

- Infinity

  설명 : 양 / 음의 무한대를 나타내는 숫자값 Infiinity를 갖는다.

- NaN

  숫자가 아님을 나타내는 숫자값 NaN을 갖는다.

- undefined

  원시 타입 undefined를 값으로 갖는다.



### 3. 빌트인 전역 함수

- eval 

  설명 : 문자열 형태로 배개변수에 전달된 코드를 런타임에 동적으로 평가하고 시행하여 결과값을 반환

  여러 개의 문으로 이루어져 있다면 모든 문을 실행 후 마지막 결과값을 반환

  특징 : 엄격 모드에서 eval 함수는 기존의 스코프를 수정하지 않고 자신만의 독자적인 스코프를 생성한다.

- isFinite

  설명 : 매개 변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 반환

  매개 변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행

- isNaN

  설명 : 매개변수에 전달된 값이 NaN인지 검사하여 그 결과를 불리언 타입으로 반환

- parseFloat

  설명 : 매개변수에 전달된 문자열을 부동소수점 숫자로 변환하여 반환함

- parseint

  설명 : 매개변수에 전달된 문자열을 정수형 숫자로 해석하여 반환함

- encodeURI / decodeURI

  설명 : encodeURI 함수는 매개변수로 전달된 URI를 인코딩함

- encodeURIComponent / decodeURIComponent

  설명 : 매개변수로 전달된 URI 구성 요소를 인코딩한다.

  



## 21. this

### 1. this  키워드

- 의미 : 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수
- 특징 : this 바인딩은 함수 호출 방식에 의해 동적으로 결정됨
- 용어정리 :
  1. 바인딩 : 식별자와 값을 연결하는 과정을 의미



### 2. 함수 호출방식과  this바인딩

|                       함수 호출 방식                       |                         this 바인딩                          |
| :--------------------------------------------------------: | :----------------------------------------------------------: |
|                       일반 함수 호출                       |                          전역 객체                           |
|                        메소드 호출                         |                     메소드를 호출한 객체                     |
|                      생성자 함수 호출                      |            생성자 함수가 (미래에) 생성할 인스턴스            |
| Function.prototype.apply/call/bind 메소드에 의한 간접 호출 | Function.prototype.apply/call/bind 메소드에 인자로 전달한 객체 |

